# Fourth Exercise :pencil:

The fourth exercise in this course deals with the numerical integration of the function

$$f(x)=e^x \cos(x)$$

[Here]("https://github.com/EnricoSc1/SCPS/tree/main/code/Fourth_Exercise") are the files written in C and Python. These are based on the following requests:
![FourthExercise](https://raw.githubusercontent.com/EnricoSc1/SCPS/refs/heads/main/images/Task04.png)

## C: Trapezoidal rule and GSL library
First, here are the headers and two custom functions:
<center>
  <img src="https://raw.githubusercontent.com/EnricoSc1/SCPS/refs/heads/main/images/ex_4_head.png" 
  alt="FourthHeaders" />
</center>
then the code for the numerical integration via the trapezoidal rule is
<center>
  <img src="https://raw.githubusercontent.com/EnricoSc1/SCPS/refs/heads/main/images/ex_4_trap.png" 
  alt = "FourthTrap" />
</center>

Briefly, the user is prompted with the number of sampling points N to divide the integration interval in sub-intervals of equal length $\Delta x = \frac{x_{sup}-x_{inf}}{N}$. The program then write the sampling points $x_k$ and their images $f(x_k)$ in a text file organized in rows and columns. Since the partition has a regular spacing, the trapezoidal rule states that:

$$\int_a^b dx f(x)\approx\Delta x\left(\frac{f(x_{0}+f(x_N)}{2}+\sum_{k=1}^{N-1}f(x_k)\right).$$

The variable **first_piece** represents the first term in parenthesis, while **second_piece** is computed in a *for loop* increasing its value iteratively over the number of sampling points. 
A better way to numerically integrate relies on the algorithms of the [GSL library](https://www.gnu.org/software/gsl/), specifically the [QAG algorithm](https://www.gnu.org/software/gsl/doc/html/integration.html#qag-adaptive-integration) for adaptive integration:
<center>
  <img src="https://github.com/EnricoSc1/SCPS/blob/main/images/ex_4_gsl.png?raw=true" 
  alt="FourthGSL" />
</center>
As result, the execution of the full code prints in the terminal:
<center>
  <img src="https://raw.githubusercontent.com/EnricoSc1/SCPS/refs/heads/main/images/ex_4_print_c.png" 
  alt="FourthPrint" />
</center>

## Q&A :question:
1) How far is the approximation from the analytic solution $I=\frac{e^{\pi/2}-1}{2}$? How can you reduce the relative error? Which is the minimum relative error you can find using the techniques you described in the previous points?\
The trapezoidal rule provides a good approximation of the true result, provided the interval is divided into a sufficient number of sampling points. In the case of $N=10^4$, the relative error is $\mathcal O(10^{-8})$. However, the QGA algorithm of the GSL library provides a more accurate result, reaching an extremely low relative error of $\mathcal O(10^{-17})$. Trying to reduce the relative error of the trapezoidal method by increasing the number of sampling points helps improving the accuracy only up to a certain point, as shown below in different tests:
	<center>
	  <img src="https://raw.githubusercontent.com/EnricoSc1/SCPS/refs/heads/main/images/ex_4_minim.png" 
	  alt="FourthPrint" />
	</center>

	For $N=10^7,10^8,10^9$ the resulting errors are $\mathcal O (10^{-12})$, $\mathcal O (10^{-13})$, $\mathcal O (10^{-12})$ suggesting that the best accuracy is achieved around $10^8$ sampling points. Beyond this, increasing this number leads to a loss of precision due to the limitations of floating-point arithmetic.

2) 	Using the output file you produce, use an interpreted language to calculate the same
	integral: is this output similar to the one in the previous point? And how close it is?\
		Here is the task written in Python where the trapezoidal rule is compared against the [Simpson's rule](https://en.wikipedia.org/wiki/Simpson%27s_rule) for numerical integration implemented in the [SciPy](https://scipy.org/) library:
	<center>
	  <img src="https://raw.githubusercontent.com/EnricoSc1/SCPS/refs/heads/main/images/ex_4_py_code.png" alt="FourthPrint" />
	</center> 
	The output of the Python program, which takes the data file generated by the previous code 	
	as input, is shown here: 
	<center>
	<img src="https://raw.githubusercontent.com/EnricoSc1/SCPS/refs/heads/main/images/ex_4_py_term.png" 
	  alt="FourthPrint" />
	</center> 
	Setting $N=10^4$ the errors produced by the trapezoidal rule in compiled and interpreted languages are of the same order of magnitude. Simpson's rule is more accurate than both, but still nowhere near as accurate as the QAG algorithm.



